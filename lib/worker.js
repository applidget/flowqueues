// Generated by CoffeeScript 1.7.1

/*
Flowqueues - Queue based programming for node.js
(c) Copyright 2014 Applidget SAS
Released under the MIT License
 */

(function() {
  var Queue, Sequencer, TaskPerformer, Worker, async, helpers, log, util, _;

  TaskPerformer = require("./task_performer").TaskPerformer;

  Sequencer = require("./sequencer").Sequencer;

  Queue = require("./queue").Queue;

  helpers = require("./helpers");

  async = require("async");

  log = require("util").log;

  util = require("util");

  _ = require("underscore");

  Worker = (function() {
    function Worker(client) {
      this.client = client;
      this.config = this.client.config;
      this.dataSource = this.config.dataSource;
      this.working = false;
      this.sequencer = new Sequencer();
      this.timeOuts = {};
    }

    Worker.prototype.work = function() {
      var jobDescription, jobName, _ref, _results;
      if (this.working === true) {
        log("Warning: Already working");
        return;
      }
      log("Flowqueues Starting with queues " + (this.config.queues.join(",")));
      this.working = true;
      _ref = this.config.jobDescriptions;
      _results = [];
      for (jobName in _ref) {
        jobDescription = _ref[jobName];
        _results.push((function(_this) {
          return function(jobName, jobDescription) {
            var name, taskDescription, _ref1, _results1;
            _ref1 = jobDescription.taskDescriptions;
            _results1 = [];
            for (name in _ref1) {
              taskDescription = _ref1[name];
              _results1.push((function(name, taskDescription) {
                return _this.unregisterWorkingJobsForTask(jobName, name, function() {
                  return _this.processTaskForName(jobName, name);
                });
              })(name, taskDescription));
            }
            return _results1;
          };
        })(this)(jobName, jobDescription));
      }
      return _results;
    };

    Worker.prototype.stop = function() {
      var key, to, _i, _len, _ref, _results;
      _ref = this.timeOuts;
      _results = [];
      for (to = _i = 0, _len = _ref.length; _i < _len; to = ++_i) {
        key = _ref[to];
        _results.push((function(key, to) {
          return clearTimeout(to);
        })(key, to));
      }
      return _results;
    };

    Worker.prototype.unregisterWorkingJobsForTask = function(jobName, taskName, cbs) {
      return this.dataSource.del(Queue.workingSetNameForTaskName(jobName, taskName), function(err, _) {
        return cbs();
      });
    };

    Worker.prototype.processTaskForName = function(jobName, taskName, previouslyRemaining) {
      var jobDescription;
      if (previouslyRemaining == null) {
        previouslyRemaining = 0;
      }
      jobDescription = this.config.jobDescriptions[jobName];
      return this.sequencer.scheduleInvocation((function(_this) {
        return function(next) {
          var leCallback, schedulePolling;
          if (taskName === jobDescription.firstTaskName && (_this.timeOuts[jobName] != null)) {
            clearTimeout(_this.timeOuts[jobName]);
            _this.timeOuts[jobName] = null;
          }
          leCallback = function(nowRemaining) {
            if (nowRemaining == null) {
              nowRemaining = 0;
            }
            return _this.processTaskForName(jobName, taskName, nowRemaining);
          };
          schedulePolling = function() {
            if (taskName === jobDescription.firstTaskName) {
              return _this.timeOuts[jobName] = setTimeout(leCallback, _this.config.timeoutInterval);
            }
          };
          if (helpers.vverbose()) {
            log("*** Looking up " + taskName + " (" + jobName + ")");
          }
          return _this.isWorkerAvailableForTaskName(jobName, taskName, previouslyRemaining, function(isAvailable, howMany) {
            var taskDescription;
            if (!isAvailable) {
              next();
              return;
            }
            taskDescription = jobDescription.taskDescriptions[taskName];
            return _this.reserveJob(jobName, taskName, function(foundJob, queue) {
              if (foundJob != null) {
                if (helpers.verbose()) {
                  log("Got " + taskName + " " + (util.inspect(foundJob)));
                }
                if (howMany > 1) {
                  leCallback(howMany - 1);
                }
                return _this.performTaskOnJob(jobName, foundJob, taskDescription, queue, next, leCallback);
              } else {
                next();
                return schedulePolling();
              }
            });
          });
        };
      })(this));
    };

    Worker.prototype.isWorkerAvailableForTaskName = function(jobName, taskName, previouslyRemaining, cbs) {
      return this.client.workingTasksCount(jobName, taskName, (function(_this) {
        return function(count) {
          var jobDescription, status, taskDescription;
          jobDescription = _this.config.jobDescriptions[jobName];
          taskDescription = jobDescription.taskDescriptions[taskName];
          status = false;
          if (count < taskDescription.concurrency) {
            status = true;
          }
          return cbs(status, taskDescription.concurrency - count);
        };
      })(this));
    };

    Worker.prototype.performTaskOnJob = function(jobName, jobData, taskDescription, queue, next, callback) {
      var jobClone;
      jobClone = helpers.clone(jobData);
      return this.registerJobInProgress(jobName, jobClone, taskDescription.name, (function(_this) {
        return function(err) {
          process.nextTick(function() {
            return TaskPerformer.performTask(_this.config.jobsDir(), taskDescription, jobData, function(status) {
              return _this.sequencer.scheduleInvocation(function(done) {
                return _this.unregisterJobInProgress(jobName, jobClone, taskDescription.name, function(err) {
                  var nextTaskName;
                  done();
                  nextTaskName = taskDescription.getNextTaskNameForKey(status);
                  if (helpers.verbose()) {
                    log("Done " + taskDescription.name + "!");
                  }
                  if (nextTaskName == null) {
                    if (helpers.vverbose()) {
                      log("" + jobName + " finished with status " + status + " on " + taskDescription.name);
                    }
                    return callback();
                  } else {
                    return _this.client.enqueueForTask(jobName, nextTaskName, jobData, queue, false, function() {
                      _this.processTaskForName(jobName, nextTaskName);
                      return callback();
                    });
                  }
                });
              });
            });
          });
          return next();
        };
      })(this));
    };

    Worker.prototype.registerJobInProgress = function(jobName, jobData, taskName, cbs) {
      var data;
      data = helpers.encode(jobData);
      return this.dataSource.rpush(Queue.workingSetNameForTaskName(jobName, taskName), data, (function(_this) {
        return function(err, _) {
          return cbs(err);
        };
      })(this));
    };

    Worker.prototype.unregisterJobInProgress = function(jobName, jobData, taskName, cbs) {
      var data, key;
      if (cbs == null) {
        cbs = null;
      }
      data = helpers.encode(jobData);
      key = Queue.workingSetNameForTaskName(jobName, taskName);
      return this.dataSource.lrem(key, 1, data, (function(_this) {
        return function(err, _) {
          if (cbs != null) {
            return cbs(err);
          }
        };
      })(this));
    };

    Worker.prototype.reserveJobOnQueue = function(jobName, taskName, queue, cbs) {
      var ignoreHost;
      ignoreHost = taskName === this.config.jobDescriptions[jobName].firstTaskName;
      return this.dataSource.lpop(Queue.pendingQueueNameForTaskName(jobName, taskName, queue, ignoreHost), (function(_this) {
        return function(err, res) {
          var job;
          job = helpers.decode(res);
          return cbs(job);
        };
      })(this));
    };

    Worker.prototype.reserveJob = function(jobName, taskName, foundJobCbs, queue) {
      var block, finalStep, foundJob, queueIndex, test;
      queueIndex = 0;
      foundJob = null;
      test = (function(_this) {
        return function() {
          return (foundJob == null) && queueIndex < _this.config.queues.length;
        };
      })(this);
      finalStep = (function(_this) {
        return function(err) {
          return foundJobCbs(foundJob, _this.config.queues[queueIndex]);
        };
      })(this);
      block = (function(_this) {
        return function(cbs) {
          return _this.reserveJobOnQueue(jobName, taskName, _this.config.queues[queueIndex], function(job) {
            if (job != null) {
              foundJob = job;
            } else {
              queueIndex += 1;
            }
            return cbs();
          });
        };
      })(this);
      return async.whilst(test, block, finalStep);
    };

    return Worker;

  })();

  exports.Worker = Worker;

}).call(this);
