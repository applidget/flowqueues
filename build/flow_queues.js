// Generated by CoffeeScript 1.6.3
(function() {
  var FlowQueues, Sequencer, TaskPerformer, async, log, os, util;

  log = require("util").log;

  TaskPerformer = require("./task_performer").TaskPerformer;

  Sequencer = require("./sequencer").Sequencer;

  util = require("util");

  async = require("async");

  os = require("os");

  FlowQueues = (function() {
    function FlowQueues(dataSource) {
      this.dataSource = dataSource;
      this.taskDescriptions = {};
      this.firstTaskName = null;
      this.working = false;
      this.timeoutInterval || (this.timeoutInterval = 5000);
      this.timeOuts = {};
      this.queues = ["critical", "main", "low"];
      this.sequencer = new Sequencer();
    }

    FlowQueues.prototype.addTaskDescription = function(taskDesc) {
      return this.taskDescriptions[taskDesc.name] = taskDesc;
    };

    FlowQueues.prototype.hostname = function() {
      return os.hostname();
    };

    FlowQueues.prototype.setFirstTaskDescription = function(fistTaskName) {
      return this.firstTaskName = fistTaskName;
    };

    FlowQueues.createWorker = function(dataSource) {
      return new FlowQueues(dataSource);
    };

    FlowQueues.prototype.encode = function(hash) {
      return JSON.stringify(hash);
    };

    FlowQueues.prototype.decode = function(json) {
      var res;
      res = null;
      try {
        res = JSON.parse(json);
      } catch (_error) {
        log("PARSING ERROR: " + (util.inspect(util.inspect(json))));
      }
      return res;
    };

    FlowQueues.prototype.reserveJobOnQueue = function(taskName, queue, cbs) {
      var _this = this;
      return this.dataSource.lpop(this.pendingQueueNameForTaskName(taskName, queue), function(err, res) {
        var job;
        job = _this.decode(res);
        return cbs(job);
      });
    };

    FlowQueues.prototype.reserveJob = function(taskName, foundJobCbs, queue) {
      var block, finalStep, foundJob, queueIndex, test,
        _this = this;
      queueIndex = 0;
      foundJob = null;
      test = function() {
        return (foundJob == null) && queueIndex < _this.queues.length;
      };
      finalStep = function(err) {
        return foundJobCbs(foundJob, _this.queues[queueIndex]);
      };
      block = function(cbs) {
        return _this.reserveJobOnQueue(taskName, _this.queues[queueIndex], function(job) {
          if (job != null) {
            foundJob = job;
          } else {
            queueIndex += 1;
          }
          return cbs();
        });
      };
      return async.whilst(test, block, finalStep);
    };

    FlowQueues.prototype.jobsDir = function() {
      return this.overridenJobDir || process.cwd();
    };

    FlowQueues.prototype.pendingTasksCount = function(taskName, cbs) {
      var _this = this;
      return this.dataSource.llen(this.pendingQueueNameForTaskName(taskName), function(err, res) {
        return cbs(res);
      });
    };

    FlowQueues.prototype.baseKeyName = function() {
      return "flowqueues";
    };

    FlowQueues.prototype.baseQueueNameForTask = function(taskName) {
      return "" + (this.baseKeyName()) + ":" + (this.hostname()) + ":" + taskName;
    };

    FlowQueues.prototype.pendingQueueNameForTaskName = function(taskName, queue) {
      return "" + (this.baseQueueNameForTask(taskName)) + ":" + queue + ":pending";
    };

    FlowQueues.prototype.workingSetNameForTaskName = function(taskName) {
      return "" + (this.baseQueueNameForTask(taskName)) + ":working";
    };

    FlowQueues.prototype.workingCountForTaskName = function(taskName, cbs) {
      var _this = this;
      return this.dataSource.llen(this.workingSetNameForTaskName(taskName), function(err, length) {
        return cbs(length);
      });
    };

    FlowQueues.prototype.isWorkerAvailableForTaskName = function(taskName, previouslyRemaining, cbs) {
      var _this = this;
      return this.workingCountForTaskName(taskName, function(count) {
        var status, taskDescription;
        taskDescription = _this.taskDescriptions[taskName];
        status = false;
        if (count < taskDescription.maxParallelInstances) {
          status = true;
        }
        return cbs(status, taskDescription.maxParallelInstances - count);
      });
    };

    FlowQueues.prototype.enqueueForTask = function(taskName, job, queue, cbs) {
      var encodedJob,
        _this = this;
      if (cbs == null) {
        cbs = null;
      }
      encodedJob = this.encode(job);
      return this.dataSource.rpush(this.pendingQueueNameForTaskName(taskName, queue), encodedJob, function(err, _) {
        if (cbs != null) {
          return cbs(err);
        }
      });
    };

    FlowQueues.prototype.enqueue = function(job, cbs) {
      var queue;
      if (cbs == null) {
        cbs = null;
      }
      queue = "main";
      if (this.queues.length > 0) {
        queue = this.queues[0];
      }
      return this.enqueueTo(job, queue, cbs);
    };

    FlowQueues.prototype.enqueueTo = function(job, queue, cbs) {
      var taskDesc;
      if (cbs == null) {
        cbs = null;
      }
      taskDesc = this.taskDescriptions[this.firstTaskName];
      return this.enqueueForTask(taskDesc.name, job, queue, cbs);
    };

    FlowQueues.prototype.registerJobInProgress = function(job, taskName, cbs) {
      var data,
        _this = this;
      data = this.encode(cbs);
      return this.dataSource.rpush(this.workingSetNameForTaskName(taskName), data, function(err, _) {
        return cbs(err);
      });
    };

    FlowQueues.prototype.unregisterJobInProgress = function(job, taskName, cbs) {
      var data, key,
        _this = this;
      if (cbs == null) {
        cbs = null;
      }
      data = this.encode(cbs);
      key = this.workingSetNameForTaskName(taskName);
      return this.dataSource.lrem(key, 1, data, function(err, _) {
        if (cbs != null) {
          return cbs(err);
        }
      });
    };

    FlowQueues.prototype.performTaskOnJob = function(job, taskDescription, queue, next, callback) {
      var _this = this;
      return this.registerJobInProgress(job, taskDescription.name, function(err) {
        process.nextTick(function() {
          return TaskPerformer.performTask(_this.jobsDir(), taskDescription, job, function(status) {
            return _this.sequencer.scheduleInvocation(function(done) {
              return _this.unregisterJobInProgress(job, taskDescription.name, function(err) {
                var nextTaskNameDescription;
                done();
                nextTaskNameDescription = taskDescription.getNextTaskDescription(status);
                log("Done " + taskDescription.name + "!");
                if (nextTaskNameDescription == null) {
                  return callback();
                } else {
                  return _this.enqueueForTask(nextTaskNameDescription.name, job, queue, function() {
                    _this.processTaskForName(nextTaskNameDescription.name);
                    return callback();
                  });
                }
              });
            });
          });
        });
        return next();
      });
    };

    FlowQueues.prototype.processTaskForName = function(taskName, previouslyRemaining) {
      var _this = this;
      if (previouslyRemaining == null) {
        previouslyRemaining = 0;
      }
      return this.sequencer.scheduleInvocation(function(next) {
        var leCallback, schedulePolling;
        if (_this.timeOuts[taskName] != null) {
          clearTimeout(_this.timeOuts[taskName]);
          _this.timeOuts[taskName] = null;
        }
        leCallback = function(nowRemaining) {
          if (nowRemaining == null) {
            nowRemaining = 0;
          }
          return _this.processTaskForName(taskName, nowRemaining);
        };
        schedulePolling = function() {
          if (taskName === _this.firstTaskName) {
            return _this.timeOuts[taskName] = setTimeout(leCallback, _this.timeoutInterval);
          }
        };
        return _this.isWorkerAvailableForTaskName(taskName, previouslyRemaining, function(isAvailable, howMany) {
          var taskDescription;
          if (!isAvailable) {
            next();
            return;
          }
          taskDescription = _this.taskDescriptions[taskName];
          return _this.reserveJob(taskName, function(foundJob, queue) {
            if (foundJob != null) {
              log("Got " + taskName + " " + (util.inspect(foundJob)));
              if (howMany > 1) {
                leCallback(howMany - 1);
              }
              return _this.performTaskOnJob(foundJob, taskDescription, queue, next, leCallback);
            } else {
              next();
              return schedulePolling();
            }
          });
        });
      });
    };

    FlowQueues.prototype.stop = function() {
      var key, to, _i, _len, _ref, _results;
      _ref = this.timeOuts;
      _results = [];
      for (to = _i = 0, _len = _ref.length; _i < _len; to = ++_i) {
        key = _ref[to];
        _results.push((function(key, to) {
          return clearTimeout(to);
        })(key, to));
      }
      return _results;
    };

    FlowQueues.prototype.unregisterWorkingJobsForTask = function(taskName, cbs) {
      return this.dataSource.del(this.workingSetNameForTaskName(taskName), function(err, _) {
        return cbs();
      });
    };

    FlowQueues.prototype.work = function() {
      var name, taskDescription, _ref, _results,
        _this = this;
      if (this.working === true) {
        log("Warning: Already working");
        return;
      }
      this.working = true;
      _ref = this.taskDescriptions;
      _results = [];
      for (name in _ref) {
        taskDescription = _ref[name];
        _results.push((function(name, taskDescription) {
          return _this.unregisterWorkingJobsForTask(name, function() {
            return _this.processTaskForName(name);
          });
        })(name, taskDescription));
      }
      return _results;
    };

    return FlowQueues;

  }).call(this);

  exports.FlowQueues = FlowQueues;

}).call(this);
